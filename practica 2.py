# -*- coding: utf-8 -*-
"""Copia de Trabajo practico 2_ Tipos de datos Abstractos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12bbqTCe1eVJ2dA6O-NkMHDBjbNzLtDG2

# ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png) **Trabajo Práctico 2: Tipos de datos abstractos** ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png)

En este trabajo práctico, vamos a trabajar con la definición de tipos de datos abstractos en Python. Recuerden crear una copia de este archivo en su ***Google Drive*** para tener permisos de edición.

### Sergio: **sergio.gonzalez@unahur.edu.ar** ###
### Martin: **martin.pustilnik@unahur.edu.ar** ###

**En cada ejercicio, luego de implementar el TDA pedido, tienen que probar cada una de las operaciones en un programa principal, ejecutando cada una de ellas**

**En el video les comenté de la función \_\_str__ para la representación de variables de los TDAs, en lugar de \_\_str__ pueden implementar \_\_repr__ que es similar pero más general (No solo sirve para el *print*, sino para la representación en general de variables del TDA)**
"""

def validarTipo2(variable, nombre, tipo, condicion = True):
  if isinstance(variable, tipo) and condicion:
    return variable
  else:
    raise Exception("La variable " + nombre + " debe ser de tipo " + str(tipo) + ". o falla la condicion "  )

def validarTipo(variable, nombre, tipo):
  if isinstance(variable, tipo):
    return variable
  else:
    raise Exception("La variable " + nombre + " debe ser de tipo " + str(tipo) + ".")

def validarAño(año):
  if validarTipo(año, "año", int) and año >= 1870:
    return año
  else:
    raise Exception("Año incorrecto")


def validarAltura(altura):
  if validarTipo(altura, "altura", float) and altura > 0:
    return altura
  else:
    raise Exception("Altura incorrecta")

# vamos a hacer un TDA que represente el tiempo medido en hs, seg y min

# interfaz
#  def __init__(self, hs, min, seg):
#  def __repr__(self):
#  def enMinutos(self):

class X:
  def __init__(self, hs, min, seg):
    self._hs = hs
  def __repr__(self):
    return "X"

class Tiempo:
  def __init__(self, hs, min, seg):
    # estructura de datos
    self._algoString = X(0,0,0)
    self._hs = hs
    self._min = validarTipo(min, "min", int) # validarTipo2(min, "min", int, min < 60)
    self._seg = validarTipo2(seg, "seg", int, seg < 60)
    self._tiempoEnMinutos = self._hs*60 + self._min

  def tiempoEnMinutos(self):
    return self._hs*60 + self._min

  def __repr__(self):
    varPrivada = self._algoString.__repr__() + self._hs.__repr__() +":"+ str(self._min) +":"+ str(self._seg)
    return varPrivada



instancia1 = Tiempo(2,20,1)
instancia1 = Tiempo(2,20,10)
print(instancia1)
print(instancia1.tiempoEnMinutos())
# print(instancia1.enMinutos())
# print(Tiempo.pasarHsAMinutoshs(1))
# print(Tiempo.tiempoDesdeSegundos(100))

"""TDA :  objeto real (ej universidad)
Modelo computacional:
-que cosas nos interesan modelar de la universidad?

Modelo1

nombre
cantidad de alumnos
carreras que ofrece

-puede haber mas de un modelo...

Modelo2
nombre
los alumnos en si
que materias cursa
carreras que ofrece

-Implementacion1 (estructura de datos de representacion)

nombre: va a ser un string
las materias:  van a a ser una lista.

-Implementacion

nombre: va a ser un string
las materias:  van a a ser un diccionario.

### **Ejercicio 1**

Implementar el TDA "Propiedad" que modela un inmueble, con una estructura definida por los siguientes componentes:
- Calle
- Número
- Localidad
- Año de construcción
- Cantidad de ambientes

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias, teniendo en cuenta que solo se almacenan propiedades construidas luego de 1870.
- \_\_repr__: Al usar la función *print* con una variable del tipo propiedad debe mostrar: **'calle' 'numero' ('localidad')**.
- mismaLocalidad: Operación que recibe dos propiedades y retorna *True* si estan en la misma localidad y *False* en caso contrario.
- mayorNumeración: Operación que recibe dos propiedades y si están en la misma calle, retorna la que posee mayor numeración. Si están calles diferentes debe lanzar una excepción.
- calculaImpuestoARBA: Operación que retorna el porcentaje de impuesto inmobiliario de una propiedad, según la siguiente regla:
 - Propiedades entre 1870 y 1949:
   - Entre 1 y 3 ambientes: 5% de impuesto
   - Entre 4 y 6 ambientes: 10% de impuesto
   - Más de 6 ambientes: 25 % de impuesto
 - Propiedades desde 1950 hasta la actualidad:
   - Entre 1 y 5 ambientes: 5% de impuesto
   - Más de 5 ambientes: 35 % de impuesto
"""

def validarAño(año):
    if(año > 1870):
      return año
    else:
      raise Exception("El año debe ser mayor a 1870")

class Propiedad:
  def __init__(self, calle, numero, localidad, año, cantAmb):
      self._calle = calle
      self._numero = numero
      self._localidad = localidad
      self._año = validarAño(año)
      self._cantAmb = cantAmb

  def mismaLocalidad(self, propiedad2):
    print(self._localidad == propiedad2._localidad)

  def mismaCalle(self, propiedad2):
    return self._calle == propiedad2._calle

  def numeroMasAlto(self, propiedad2):
    if(self._numero > propiedad2._numero):
      print(self)
    else:
      print(propiedad2)

  def mayorNumeracion(self, propiedad2):
    if(self.mismaCalle(propiedad2)):
      self.numeroMasAlto(propiedad2)
    else:
      raise Exception("Las propiedades deben estar ubicadas en la misma calle")

  def calcularImpuestoARBAVieja(self):
    if(self._cantAmb <= 3):
      print('Debe pagar 5% de impuesto')
    elif(self._cantAmb > 3 and self._cantAmb <= 6):
      print('Debe pagar 10% de impuesto')
    else:
      print('Debe pagar 25% de impuesto')

  def calcularImpuestoARBANueva(self):
    if(self._cantAmb < 5):
      print('Debe pagar 5% de impuesto')
    else:
      print('Debe pagar 35% de impuesto')

  def calculaImpuestoARBA(self):
    if(self._año <= 1949):
      self.calcularImpuestoARBAVieja()
    else:
      self.calcularImpuestoARBANueva()



  def __repr__(self):
    prop = f"{self._calle}, {self._numero}, {self._localidad}"
    return(prop)

propiedad1= Propiedad("ralico", 14, "Moron", 2110, 8)
propiedad2= Propiedad("ralico", 13, "bsas", 1910, 21)

propiedad1.mismaLocalidad(propiedad2)
propiedad1.mayorNumeracion(propiedad2)
propiedad2.calculaImpuestoARBA()



"""### **Ejercicio 2**

Implementar el TDA "Quiniela" que modela un juego de quiniela con dos números premiados. La estructura contiene:
- Primer número premiado
- Segundo número premiado
- Multiplicador (cuánto se paga por cada peso apostado)

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias, teniendo en cuenta que los números que participan se encuentran entre 0 y 999.
- \_\_repr__: Al usar la función *print* con una variable del tipo quiniela debe mostrar: **Primer número ganador: 'numero' - Segundo número ganador: 'numero' - Paga: 'multiplicador'X**.
- esNumeroGanador: Operación que recibe un número por parámetros y retorna *True* si el número resultó ganador o *False* en caso contrario.
- importeAPagar: Operación que recibe un número y el monto apostado por parámetros y retorna el importe a pagar si la apuesta es ganadora o 0 en caso contrario. Si el número es el primer premio, se paga 'mutiplicador' por cada peso apostado, si es el segundo premio se paga la mitad. Solo se aceptan apuestas hasta $1000.
- premiadosCercanos: Operación que retorna *True* si los números premiados están a menos de 10 números de distancia y *False* en caso contrario.



"""

def validarNumero(num):
  if(num >= 0 and num <= 999):
    return num
  else:
    raise Exception('El numero ingresado debe ser mayor o igual a cero y menor a 1000')

class Quiniela:

  def __init__(self, primNum, segNum, multiplicador):
    self._primNum = validarNumero(primNum)
    self._segNum = validarNumero(segNum)
    self._multiplicador = multiplicador

  def esNumeroGanador(self, num):
    print(num == self._primNum or num == self._segNum)

  def importeAPagar(self, num, importe):
    if(num > 1000):
      raise Exception('Solo se aceptan apuestas de hasta $1000')
    elif(num == self._primNum):
      print(f'${importe * self._multiplicador}')
    elif(num == self._segNum):
      print(f'${importe * (self._multiplicador / 2)}')
    else:
      print('$0')

  def premiadosCercanos(self):
    print(self._primNum + self._segNum > (self._primNum + self._segNum) - 20)

  def __repr__(self):
    prop = f"primer numero ganador: {self._primNum} - Segundo numero ganador: {self._segNum} - Paga: Multiplicador X {self._multiplicador}"
    return(prop)

quini = Quiniela(12, 85, 3)

print(quini)

quini.esNumeroGanador(5)
quini.esNumeroGanador(9)
quini.importeAPagar(5, 500)
quini.premiadosCercanos()

"""### **Ejercicio 3**

Implementar el TDA "Cuenta" que modela una cuenta bancaria, la estructura de datos esta compuesta por los siguientes componentes:
- Número de cuenta
- DNI del titular
- Saldo de cuenta actual
- Interés anual

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias.
- \_\_repr__: Al usar la función *print* con una variable del tipo cuenta debe mostrar: **Cuenta Nro: 'numero' - Titular: 'dni' ($'saldo')**.
- actualizarSaldo: Operación que actualiza el saldo de la cuenta aplicándole el interés diario (interés anual dividido entre 365).
- ingresarDinero: Operación que recibe un número e ingresa esa cantidad en la cuenta.
- retirarDinero: Operación que recibe un número y extrae esa cantidad de la cuenta (si hay saldo disponible), sino debe lanzar una excepción.
"""



"""### **Ejercicio 4**

Implementar el TDA "Tiempo" que modela una duracion en horas, minutos y segundos.

Se deben implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias, la hora debe ser un número positivo y los minutos y segundos deben ser números positivos entre 0 y 59.
- \_\_repr__: Al usar la función *print* con una variable del tipo tiempo debe mostrar: **'horas':'minutos':'segundos'**.
- tiempoASegundos: Operación que toma una variable de tipo tiempo y retorna la cantidad en segundos.
- tiemposDesdeSegundos: Operación que recibe un tiempo en segundos como parámetro y retorna una variable de tipo tiempo, en horas minutos y segundos.
- mayorDuracion: Operación que recibe dos variables de tipo tiempo y retorna la de mayor duración.
"""



"""
### **Ejercicio 4bis: TDA en dos niveles**

Modelar el TDA Cronometro, tiene un tiempo inicial y un tiempo final.

Constructor: Queremos modelar el tiempo inicial y final con el TDA Tiempo. Se pueden tener dos variables de instancia, pero que se inicializaran el otro metodo.

Comenzar: Debe recibir las hs,min y seg iniciales.

Finalizar: Debe recibir las hs,min y seg finales.

TiempoEmpleado: Devuelve una variable de tipo Tiempo con la diferencia entre el tiempo inicial y el final."""



"""### **Ejercicio 5**

Las plataformas de música online como ***YouTube*** y ***Spotify*** almacenan la información asociada a las canciones en estructuras de datos complejas para hacer las búsquedas de manera eficiente. Para esto se deben modelar las canciones. Implementar el TDA "Cancion" con los siguientes componentes:
- Nombre
- Artista
- Duración
- Género musical (6 posibles: Rock, Jazz, Blues, Funk, Reggae y Rap).
- Año de edición
- Número de likes

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias.
- \_\_repr__: Al usar la función *print* con una variable del tipo canción debe mostrar: **'nombre' - 'artista' ('duracion')**.
- mayorDuracion: Operación que recibe dos canciones por parámetros y retorna la de mayor duración.
- agregaLikes: Operación que recibe un número e incrementa la cantidad de likes de la canción en ese número.
- masVotada: Operacion que recibe dos canciones y sin son del mismo artista y del mismo género musical, retorna la que tiene mayor cantidad de likes. En caso contrario debe lanzar una excepción.
"""

from sre_constants import NOT_LITERAL_IGNORE
class Cancion:
  def __init__(self, nombre, artista, duracion, genero, año, cantLikes):
    # xxx falta validaciones
    self._nombre = nombre
    self._artista = artista
    self._duracion = validarTipo(duracion,"duracion",Tiempo)
    # (6 posibles: Rock, Jazz, Blues, Funk, Reggae y Rap).
    self_genero = genero
    self._año = año
    self._cantLikes = cantLikes

  def __repr__(self):
    var = self._nombre + " - " + self._artista + " (" + self._duracion.__repr__() + ")"
    return var

  def duracion(self):
    return self._duracion

  def mayorDuracion(self, cancion2):
    cancionAux = self
    if self._duracion.tiempoEnMinutos() < cancion2.duracion().tiempoEnMinutos():
      cancionAux = cancion2
    return cancionAux

  # seria mas maduro utilizar esto
  #  return self._duracion.mayorDuracion(cancion2.duracion())


c1 = Cancion("Sultans of Swing", "Dire Straits", Tiempo(0,5,48), "Rock", 1978, 250)
c2 = Cancion("(Don’t Fear) The Reaper", "Blue Öyster Cult", Tiempo(0,5,8), "Rock", 1976, 75)
c3 = Cancion("Money for Nothing", "Dire Straits", Tiempo(0,8,26), "Rock", 1985, 150)

cancion1 = Cancion("Devorame otra vez","Lalo rodrigez", Tiempo(0,6,0), "Salsa", "1989", 100)
cancion2 = Cancion("Devorame otra vez","Lalo rodrigez", Tiempo(0,5,0), "Salsa", "1989", 100)
print(c2.mayorDuracion(c3))

class Quiniela:
  def __init__(self,primerNumero,segundoNumero):
    pepe = self._primerNumero
    self._primerNumero = self.validarNumero(primerNumero)
    self._segundoNumero = self.validarNumero(segundoNumero)

  def __repr__(self):
    ganadores = "Primer numero ganador: " + self._primerNumero.__repr__() + " Segundo numero Ganador: " + self._segundoNumero.__repr__()
    return ganadores

  def validarNumero(self,numeroAca):
    if 0<= numeroAca <=999:
      return numeroAca
    else:
      raise Exception("El Numero no pertenece a la quinela")

  def esNumeroGanador(self,numeroAca):
    return self._primerNumero >= numeroAca >= self._segundoNumero

print(Quiniela(2,4))